stdlib5.kcom : 동일 컴퓨터 내 프로세스 간 통신을 위한 간단한 소켓 연결망.

<python>
func pack(int port, bytes key) -> str address
# 포트 번호와 세션 키를 문자열로 묶습니다. 세션 키는 48의 약수 길이여야 합니다.
func unpack(str address) -> (int port, bytes key)
# 문자열에서 포트 번호와 세션 키를 분리합니다. 키는 항상 48바이트를 반환합니다.
class server
    func send(bytes data)
    # 이진 데이터를 전송합니다. 전송 후 소켓은 닫힙니다.

    .ipv6 bool # IPv6 주소를 사용할지 여부. 기본값은 True(IPv6사용).
    .port int # 포트 번호. 기본값은 13600번 포트.
    .close int # 타임아웃 시간. 기본값은 150초. 음수일 경우 시간초과 오류 없음.
    .msg str # 추가로 보낼 메세지. (프로그램 제어용)

class client
    func recieve() -> bytes data
    # 이진 데이터를 수신합니다. 수신 후 소켓은 닫힙니다.

    .ipv6 bool # IPv6 주소를 사용할지 여부. 기본값은 True(IPv6사용).
    .port int # 포트 번호. 기본값은 13600번 포트.
    .close int # 타임아웃 시간. 기본값은 150초. 음수일 경우 시간초과 오류 없음.
    .msg str # 수신한 추가 메세지 저장소. (프로그램 제어용)

<go>
func Pack(int port, byte[] key) -> string address
# 포트 번호와 세션 키를 문자열로 묶습니다. 세션 키는 48의 약수 길이여야 합니다.
func Unpack(string address) -> (int port, byte[] key)
# 문자열에서 포트 번호와 세션 키를 분리합니다. 키는 항상 48바이트를 반환합니다.

func Initsvr() -> server
# 송신용 서버 역할 구조체의 기본값을 설정합니다.
struct server
    func Send(byte[] data)
    # 이진 데이터를 전송합니다. 전송 후 소켓은 닫힙니다.

    .Ipv6 bool # IPv6 주소를 사용할지 여부. 기본값은 True(IPv6사용).
    .Port int # 포트 번호. 기본값은 13600번 포트.
    .Close int # 타임아웃 시간. 기본값은 150초. 음수일 경우 시간초과 오류 없음.
    .Msg string # 추가로 보낼 메세지. (프로그램 제어용)

func Initcli() -> client
# 수신용 클라이언트 역할 구조체의 기본값을 설정합니다.
struct client
    func Recieve() -> byte[] data
    # 이진 데이터를 수신합니다. 수신 후 소켓은 닫힙니다.

    .Ipv6 bool # IPv6 주소를 사용할지 여부. 기본값은 True(IPv6사용).
    .Port int # 포트 번호. 기본값은 13600번 포트.
    .Close int # 타임아웃 시간. 기본값은 150초. 음수일 경우 시간초과 오류 없음.
    .Msg string # 수신한 추가 메세지 저장소. (프로그램 제어용)

!!! 중요 경고 !!!
KCOM5 통신은 동기적으로 동작합니다. 데이터를 모두 전송하거나 응답을 모두 받을 때까지 함수가 반환되지 않습니다.
서버 소켓이 열리지 않은 상태에서는 클라이언트 소켓을 열 수 없습니다.
한 쌍의 프로세스끼리만 통신 가능합니다. (일대일 통신)
1023 이하 포트는 예약된 특수 포트이니 10000 ~ 40000 대역의 임의의 포트 사용을 권장합니다.
안전한 통신을 위해 데이터는 simen/kaes로 암호화하는 것을 추천합니다.
포트 번호와 키를 묶어 문자열로 패킹/언패킹 할 수 있으며,
보안을 위해 키는 48바이트 사용이 좋으나 너무 길다면 48의 약수 길이로 간략화한 키를 사용할 수 있습니다.
리눅스와 윈도우 상의 루프백 IP 표현이 다를 수 있습니다. 기본적으로 윈도우 양식을 사용합니다.

프로세스 간 통신을 위해 TCP 소켓을 사용합니다.
python과 go 사이 상호 운용이 가능합니다.
다음과 같은 방식으로 서버-클라이언트가 통신하며 서버측의 데이터를 클라이언트에게 보냅니다.
1. 서버 소켓이 열립니다.
1b. 만약 시간초과 설정값이 양수이고 지정 시간 동안 클라이언트 연결이 없다면 타임아웃으로 종료됩니다.
2. 클라이언트 소켓이 열립니다.
3. 클라이언트 측에서 KCOM5 + 3바이트 난수를 보냅니다.
4. 서버 측에서 8바이트 값을 읽고 KCOM5로 시작하는지 확인합니다.
4b. 만약 KCOM5로 시작하지 않는 값을 보내왔다면 잘못된 연결로 종료합니다.
5. 서버 측에서 8바이트 값을 다시 반송합니다.
6. 클라이언트 측에서 8바이트 값을 읽고 보낸 값과 동일한지 확인합니다.
6b. 만약 동일한 8바이트 값이 아니라면 잘못된 연결로 종료합니다.
7. 서버 측에서 추가 메세지 문자열을 UTF-8로 인코딩해 로컬메세지 바이트를 만듭니다.
8. 서버 측에서 로컬메세지 길이(4B) + 로컬메세지 + 메인 데이터 길이(8B) + 메인 데이터를 보냅니다.
9. 클라이언트 측에서 로컬메세지와 메인데이터를 받고 문자열 메세지로 복구합니다.
10. 소켓을 닫고, 메세지는 객체 내부 필드에 저장되며, 메인 데이터 바이트는 반환합니다.
